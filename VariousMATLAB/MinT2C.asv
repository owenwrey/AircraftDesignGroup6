% Minimum Time to Climb
clear; clc; close all;

% sea level to 46,250 ft

%% Update checklist, MAKE SURE TO DO THIS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% things to update include: MTOW, weight fraction, wing loading, max alt,
% thrust, drag values, TSFC, min/max speed in speed array, EnHt start and end, 


%% Inputs
TLapse = griddedInterpolant([0, 10000, 20000, 30000, 40000, 50000], ...
                            [1, 0.80, 0.60, 0.40, 0.20, 0.15], ...
                            'linear','nearest');

rho_SL = 0.0023769;
mps2kts = 1.94384;      % meters per sec to knots
kts2fps = 1/0.59248;    % knots to feet per sec
NM2ft = 6067;           % nautical miles to feet
ft2m = 0.305;           % feet to meters

W0 = 76965;             % MTOW (lbm)
WtFrac = 1;             % weight fraction
W_S = 130;              % takeoff wing loading (psf)
S = W0/W_S;             % wing area ft^2
maxAlt = 46250;         % service ceiling, ft
fullThrust = 44000;     % lb

CD0 = 0.008;            
K1 = 0;      
K2 = 0.08;   
CDR = 0;     

istart = 1;
iend = 400;

SFC_climb = 0.75;
THROT = 1;

Alt(istart:iend) = linspace(0,maxAlt, iend)';   % altitude array
[T, a, P, rho] = atmosisa(Alt*ft2m);
rho = rho*0.00194032; % to slug/ft^3
thrustLapse = TLapse(Alt)';

KTAS = linspace(200,1000,iend)';                % generate speed array

EnHt_start = (KTAS(1)*kts2fps).^2/(2*32.2);
EnHt_end   = maxAlt + (600*kts2fps).^2/(2*32.2);

EnHt = linspace(EnHt_start,EnHt_end,iend)';

%% Build the grids

[ALT_grid, KTAS_grid] = meshgrid(Alt, KTAS);    % generate speed and alt grid
V_grid = KTAS_grid * kts2fps;

q_grid = 0.5 .* (rho') .* (V_grid.^2);          % generate q grids

CL_grid = W0 ./ (q_grid .* S);                  % generate grids for CL and CD
CD_grid = CD0 + K1 * CL_grid + K2 * CL_grid.^2;

Drag_grid = q_grid .* S .* CD_grid;
Thrust_grid = fullThrust .* thrustLapse';

Ps_grid = (Thrust_grid - Drag_grid) .* V_grid ./ W0;

% Energy height map
En_grid = ALT_grid + (V_grid.^2)/(2*32.2);

%% Best Excess Power Logic

tol = 10000;   % wide tolerance for matching energy height

bestPs  = zeros(length(EnHt),1);
bestAlt = zeros(length(EnHt),1);
bestV   = zeros(length(EnHt),1);

for i = 1:length(EnHt)
    mask = abs(En_grid - EnHt(i)) < tol;
    Ps_candidates = Ps_grid(mask);

    if isempty(Ps_candidates)
        bestPs(i)  = NaN;
        bestAlt(i) = NaN;
        bestV(i)   = NaN;
        continue
    end

    [bestPs(i), idx] = max(Ps_candidates);

    ALT_candidates = ALT_grid(mask);
    V_candidates   = V_grid(mask);

    bestAlt(i) = ALT_candidates(idx);
    bestV(i)   = V_candidates(idx);
end

% ============================================================
% === Remove NaNs from the climb path ===
% ============================================================

good = ~isnan(bestPs);
bestPs  = bestPs(good);
bestAlt = bestAlt(good);
bestV   = bestV(good);
EnHt    = EnHt(good);



initAlt = 0;
initV_kts = 200;
initV = initV_kts*kts2fps;

q_init = 0.5*rho(1)*initV^2;

CL_init = W0/(q_init*S);
CD_init = CD0 + K2*CL_init^2;

D_init = q_init*S*CD_init;
T_init = fullThrust*thrustLapse(1);

Ps_init = (T_init - D_init)*initV/W0;

EnHt_init = initAlt + initV^2/(2*32.2);

bestAlt = [initAlt; bestAlt];
bestV   = [initV;   bestV];
bestPs  = [Ps_init; bestPs];
EnHt    = [EnHt_init; EnHt];



% ============================================================
% === FORCE FINAL STATE: (46,250 ft, 600 KTAS) ===
% ============================================================

finalAlt    = maxAlt;     % 46,250 ft
finalV_kts  = 600;        % 600 KTAS
finalV      = finalV_kts * kts2fps;

q_final = 0.5 * rho(end) * finalV^2;
CL_final = W0 / (q_final * S);
CD_final = CD0 + K2 * CL_final^2;

D_final = q_final * S * CD_final;
T_final = fullThrust * thrustLapse(end);
Ps_final = (T_final - D_final) * finalV / W0;

EnHt_final = finalAlt + finalV^2/(2*32.2);

% Append the mandatory endpoint
bestAlt(end+1) = finalAlt;
bestV(end+1)   = finalV;
bestPs(end+1)  = Ps_final;
EnHt(end+1)    = EnHt_final;

% Sort (important)
[EnHt, idx] = sort(EnHt);
bestAlt = bestAlt(idx);
bestV   = bestV(idx);
bestPs  = bestPs(idx);

% ============================================================
% === Integrate time using Ps = dHe/dt ===
% ============================================================

dHe = diff(EnHt);             
Ps_mid = bestPs(1:end-1);     
dt = dHe ./ Ps_mid;           

TTC = sum(dt)/60;   % minutes

% cumulative time
t_profile = [0; cumsum(dt)];

% ============================================================
% === Store climb schedule for plotting ===
% ============================================================

Alt_profile  = bestAlt;
KTAS_profile = bestV / kts2fps;

% %% Plotting
% 
% figure;
% plot(KTAS_profile, Alt_profile, 'b', 'LineWidth', 2);
% xlabel('KTAS');
% ylabel('Altitude (ft)');
% grid on; hold on;
% title('Minimum-Time Climb Schedule');
% 
% He_bands = [ ...
%     EnHt_start; ...
%     EnHt_start + 0.25*(EnHt_end - EnHt_start); ...
%     EnHt_start + 0.50*(EnHt_end - EnHt_start); ...
%     EnHt_start + 0.75*(EnHt_end - EnHt_start); ...
%     EnHt_end ...
% ];
% 
% V_span = linspace(min(KTAS), max(KTAS), 500);
% V_fps_span = V_span*kts2fps;
% 
% for k = 1:length(He_bands)
%     He_val = He_bands(k);
% 
%     % altitude for each V on this energy-height line
%     Alt_band = He_val - (V_fps_span.^2)/(2*32.2);
% 
%     % restrict to physical
%     valid = Alt_band >= 0;
%     V_valid = V_span(valid);
%     Alt_valid = Alt_band(valid);
% 
%     plot(V_valid, Alt_valid, '--','Color',[0.4 0.4 0.4],'LineWidth',0.8);
% 
%     % Label at rightmost side
%     if ~isempty(V_valid)
%         text(V_valid(end)+5, Alt_valid(end), ...
%              sprintf('H_e = %5.0f ft',He_val), ...
%              'Color',[0.3 0.3 0.3], 'FontSize',8);
%     end
% end
% 
% hold off;
% 
% % Print TTC
% fprintf('Total Time to Climb = %.2f minutes\n', TTC);

